export E3SM_ROOT=$HOME/Code/E3SM
export TUTORIAL_ROOT=$HOME/Code/eamxx-tutorial-2025
mkdir $E3SM_ROOT/components/eamxx/src/physics/pompei
cp $TUTORIAL_ROOT/source/pompei/eamxx_template_process_interface.* $E3SM_ROOT/components/eamxx/src/physics/pompei
cp $TUTORIAL_ROOT/source/pompei/pompei* $E3SM_ROOT/components/eamxx/src/physics/pompei
cd $E3SM_ROOT/components/eamxx/src/physics/pompei
mv eamxx_template_process_interface.hpp eamxx_pompei_process_interface.hpp 
mv eamxx_template_process_interface.cpp eamxx_pompei_process_interface.cpp 
vi eamxx_pompei_process_interface.hpp

## Update the hpp interface file.
> Find and replace all "AP_TEMPLATE" strings with "POMPEI"
> Change the name attribute to a string that describes our process
> Add global parameters (variables) for this processi, under the "protected" section.

  
  util::TimeStamp m_eruption_start;
  
  std::shared_ptr<const AbstractGrid>   m_grid;
  Int m_ncols, m_nlevs;
  Field m_emission_mask;


## Configure the cpp interface file.
> Add the appropriate headers to the top of the file, note that we will need some physical constants so
  we add that header as well.

#include "physics/share/physics_constants.hpp"
#include "pompei.hpp"
#include "eamxx_pompei_process_interface.hpp"

> Find and replace all instances of "AP_TEMPLATE" with "POMPEI"
> Add the universal variable `util::TimeStamp m_eruption_start;` which will be used with pompei code to determine when ash is injected into the atmosphere.

# Define the constructor
> add the line `m_eruption_start = util::str_to_time_stamp(params.get<std::string>("eruption_date"));`
  which will define a new runtime parameter to control when the eruption starts.

# Define the set_grids function
> Note, the template already sets the grid for physics, so we don't need to change this.
  But we do want to retrieve the column and level information for this grid
  m_ncols = m_grid->get_num_local_dofs();
  m_nlevs = m_grid->get_num_vertical_levels();
> Define a set of units that we will use for adding fields to our interface
  constexpr auto Pa = ekat::units::Pa;
  constexpr auto kg = ekat::units::kg;
  constexpr auto nondim = ekat::units::Units::nondimensional();
> Extract the 3d layout from the grid, note that this is already done in the template.
> Extract the 2d layout from the grid
  const auto layout_2d = m_grid->get_2d_scalar_layout();
> Add all fields to be used by this process.  Be sure to note which are input, output or both.
  add_field<Required>("pseudo_density",layout_3d,Pa,m_grid->name());
  add_field<Computed>("ash_column_integrated",layout_2d,nondim,m_grid->name());
  add_tracer<Updated>("ash",m_grid,kg/kg);

# Define the initialize_impl function.
> We will define a mask array at initialization that will help us control where ash is added to
  the atmosphere state.  This will take a few steps which we go through now.
> We will need a couple of universal constants to calculate where to mask the ash cloud.  To access
  these we load them from physics constants.
  // Some universal constants that we will need
  using PC = scream::physics::Constants<Real>;
  constexpr Real deg2rad = PC::Pi / 180;
  constexpr Real r_earth = PC::r_earth;
> We will use the Field class to define our mask, which will come in handy when we want to apply
  the mask later on.  In `eamxx_pompei_process_interface.hpp` we can add the following

  Field m_emission_mask;
> Now we create and allocate the field 

  // We can create our helper "mask" field. It will be 1 where the volcano injection
  // in the atmosphere happens, and 0 elsewhere.
  const std::string mask_name = "emission_mask";
  constexpr auto nondim = ekat::units::Units::nondimensional();
  const auto layout_3d = m_grid->get_3d_scalar_layout(true);
  FieldIdentifier rate_fid(mask_name,layout_3d,nondim,m_grid->name());
  m_emission_mask = Field(rate_fid);
  m_emission_mask.allocate_view();
  m_emission_mask.deep_copy(0); // 0 means "not injecting here"

> To set the mask we need the latitude and longitude of the grid and the injection point.

  // The grid already stores lat/lon, so go ahead and pre-compute the mask field
  auto lat = m_grid->get_geometry_data("lat"); // WATCH OUT: it's in degrees, NOT rad
  auto lon = m_grid->get_geometry_data("lon"); // WATCH OUT: it's in degrees, NOT rad

  // Target location of volcanic eruption.  Note, for now these are hard-coded.
  auto volcano_lat = 40.8214 * deg2rad;
  auto volcano_lon = 14.4260 * deg2rad;
  auto emission_lev = 27;
  auto radius = m_params.get<double>("plume_radius_in_km");
  EKAT_REQUIRE_MSG (radius>0,
      "Error! Plume radius should be positive. Input value: " << radius << ".\n");

> Finally, we use Kokkos to determine the mask based on distance.

  // Extract Kokkos (device) views from the fields
  // NOTE: views are "just" multi-dimensional arrays, which are accessible on device
  auto emission_view = m_emission_mask.get_view<Real**>();
  auto lat_view = lat.get_view<const Real*>();
  auto lon_view = lon.get_view<const Real*>();

  // ------------------------------------------------------------------------------------------- //
  // We define a lambda function for computing the mask that we can then use with
  // Kokkos.
  // A lambda is just a function defined "on-the fly". KOKKOS_LAMBDA simply adds
  // some decoration for GPU execution, nothing to worry about for now
  auto compute_mask = KOKKOS_LAMBDA (const int icol) {
    auto lat_rad = lat_view(icol) * deg2rad;
    auto lon_rad = lon_view(icol) * deg2rad;
    auto delta_lat = lat_rad - volcano_lat;
    auto delta_lon = lon_rad - volcano_lon;

    auto dist = r_earth/1e3 * sqrt(delta_lat*delta_lat + delta_lon*delta_lon);

    // If the distance between this point and the center of the volcano is within the radius
    // set the MASK value to 1 (true).
    if (dist<radius) {
      emission_view(icol,emission_lev) = 1;
    }
  };
  // ------------------------------------------------------------------------------------------- //

  // A policy tells kokkos how to parallelize the loop. Here, we are doing
  // a single for loop over the range of indices [0,ncols)
  auto policy = Kokkos::RangePolicy<Field::device_t::execution_space>(0,ncols);

  // Execute the lambda in parallel according to the execution policy
  Kokkos::parallel_for("",policy,compute_mask);

# Define the run_impl function
> We need the pompei namespace to access the pompei functions
  using namespace pompei;
> Calculate the mass of ash injected into the atmosphere using pompei
  auto t = timestamp() + dt;
  auto rate = ash_emission_rate (t.days_from(m_eruption_start));
  auto mass = dt*rate;
> Access the fields for ash and pseudo_density to update the ash tracer with new injection
  auto qash = get_field_out("ash");
  auto rho = get_field_in("pseudo_density");
> Update ash using the mass from pompei.  Note we use field functions to simplify the code.
  // y.update(x,a,b) means y = b*y + a*x
  qash.scale(rho);
  qash.update(m_emission_mask,mass,1.0);
  qash.scale_inv(rho);

# Define the finalize_impl
> This impl typically has nothing in it, for tutorial purposes we add a print statement to show how it works.
  printf("pompei has finished\n");
